a2$get.inv() # should show the inverse
cacheSolve(a2)
a2$set(matrix(c(1,-5,0,0,1,0,0,0,1),3,3))
a2$get.inv()
cacheSolve(a2)
cacheSolve(a2)
a2$get()
a2$set.inv(matrix(c(1,-5,0,0,1,-5,-3,0,1),3,3))
a2$get.inv()
cacheSolve <- function(x, ...) {
inv <- x$get.inv() # gets the matrix inverse from the makeCacheMatrix function
if(!is.null(inv)) {
message("getting cached data")
return(inv) # returnes inv if inverse was already cached
}
data <- x$get() # gets the matrix from the makeCacheMatrix function
inv <- solve(data)
x$set.inv(inv) # setting the inverted matrix into makeCacheMatrix
inv
}
rm(list=ls())
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL # creates a varialbe called inv
set <- function(y) { # creates a set variable, copies the matrix (uses x from the upper environment)
x <<-  y
inv <<- NULL # setting inv to null
}
get <- function() x # getting the x matrix
set.inv <- function(inverse)inv <<- inverse # setting the inv matrix
get.inv <- function() inv # getting the inverted matrix -  after applying cacheSolve
list(set = set, get = get,
set.inv = set.inv,
get.inv = get.inv) #  creating public variables
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above
## If the inverse has already been calculated (and the matrix has not changed), then the cachesolve should retrieve the inverse from the cache.
cacheSolve <- function(x, ...) {
inv <- x$get.inv() # gets the matrix inverse from the makeCacheMatrix function
if(!is.null(inv)) {
message("getting cached data")
return(inv) # returnes inv if inverse was already cached
}
data <- x$get() # gets the matrix from the makeCacheMatrix function
inv <- solve(data)
x$set.inv(inv) # setting the inverted matrix into makeCacheMatrix
inv
}
cacheSolve <- function(x, ...) {
inv <- x$get.inv() # gets the matrix inverse from the makeCacheMatrix function
if(!is.null(inv)) {
message("getting cached data")
return(inv) # returnes inv if inverse was already cached
}
data <- x$get() # gets the matrix from the makeCacheMatrix function
inv <- solve(data, ...)
x$set.inv(inv) # setting the inverted matrix into makeCacheMatrix
inv
}
a<-matrix(1:4,2,2)
a
a2<-makeCacheMatrix(a)
a2$get()
a2$get.inv()
cacheSolve(a2)
a2$get.inv() # should show the inverse
cacheSolve(a2)
a2$set(matrix(c(1,-5,0,0,1,0,0,0,1),3,3))
a2$get.inv()
cacheSolve(a2)
cacheSolve(a2)
a2$get()
a2$set.inv(matrix(c(1,-5,0,0,1,-5,-3,0,1),3,3))
a2$get.inv()
a2$get()
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL # creates a varialbe called inv
set <- function(y) { # creates a set variable, copies the matrix (uses x from the upper environment)
x <<-  y
inv <<- NULL # setting inv to null
}
get <- function() x # getting the x matrix
set.inv <- function(inverse)inv <<- inverse # setting the inv matrix
get.inv <- function() inv # getting the inverted matrix -  after applying cacheSolve
list(set = set, get = get,
set.inv = set.inv,
get.inv = get.inv) #  creating public variables
}
cacheSolve <- function(x, ...) {
inv <- x$get.inv() # gets the matrix inverse from the makeCacheMatrix function
if(!is.null(inv)) {
message("getting cached data")
return(inv) # returnes inv if inverse was already cached
}
data <- x$get() # gets the matrix from the makeCacheMatrix function
inv <- solve(data)
x$set.inv(inv) # setting the inverted matrix into makeCacheMatrix
inv
}
## Write a short comment describing this function
## This function assign a matrix or get the value of a matrix that is loaded in cache or change the value of that matrix in memory
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinv <- function(solve) m <<- solve
getinv <- function() m
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
## Write a short comment describing this function
##This funtion calculate de inverse of a matrix and if the inverse is cached only get it from memory and skip the process for calculating it
##but if the inverse is not stored in cache memory the function calculates it and the inverse matrix is stored in cache memory
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinv()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinv(m)
m
}
a<-matrix(1:4,2,2)
a
a2<-makeCacheMatrix(a)
a2$get()
a2$get.inv()
cacheSolve(a2)
a2$get.inv() # should show the inverse
cacheSolve(a2)
a2$set(matrix(c(1,-5,0,0,1,0,0,0,1),3,3))
a2$get.inv()
cacheSolve(a2)
cacheSolve(a2)
a2$get()
a2$set.inv(matrix(c(1,-5,0,0,1,-5,-3,0,1),3,3))
a2$get.inv()
a2$get()
rm(list = ls())
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(inverse) m <<- inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The second function "cacheSolve" returns the inverse of "x".
## If the inverse has already been calculated (and the matrix has not changed), then "cacheSolve" retrieves
## the inverse from the cache.
cacheSolve <- function(x) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve (data)
x$setinverse(m)
m
}
a<-matrix(1:4,2,2)
a
a2<-makeCacheMatrix(a)
a2$get()
a2$get.inv()
cacheSolve(a2)
a2$get.inv() # should show the inverse
cacheSolve(a2)
a2$set(matrix(c(1,-5,0,0,1,0,0,0,1),3,3))
a2$get.inv()
cacheSolve(a2)
cacheSolve(a2)
a2$get()
a2$set.inv(matrix(c(1,-5,0,0,1,-5,-3,0,1),3,3))
a2$get.inv()
a2$get()
rm(list = ls())
makeCacheMatrix <- function(x = matrix()) {
m <- NULL # creates a varialbe called inv
set <- function(y) { # creates a set variable, copies the matrix (uses x from the upper environment)
x <<-  y
m <<- NULL # setting inv to null
}
get <- function() x # getting the x matrix
set.inv <- function(inverse)m <<- inverse # setting the inv matrix
get.inv <- function() m # getting the inverted matrix -  after applying cacheSolve
list(set = set, get = get,
set.inv = set.inv,
get.inv = get.inv) #  creating public variables
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above
## If the inverse has already been calculated (and the matrix has not changed), then the cachesolve should retrieve the inverse from the cache.
cacheSolve <- function(x, ...) {
m <- x$get.inv() # gets the matrix inverse from the makeCacheMatrix function
if(!is.null(inv)) {
message("getting cached data")
return(m) # returnes inv if inverse was already cached
}
data <- x$get() # gets the matrix from the makeCacheMatrix function
m <- solve(data)
x$set.inv(m) # setting the inverted matrix into makeCacheMatrix
m
}
a<-matrix(1:4,2,2)
a
a2<-makeCacheMatrix(a)
a2$get()
a2$get.inv()
cacheSolve(a2)
a2$get.inv() # should show the inverse
cacheSolve(a2)
a2$set(matrix(c(1,-5,0,0,1,0,0,0,1),3,3))
cacheSolve <- function(x, ...) {
m <- x$get.inv() # gets the matrix inverse from the makeCacheMatrix function
if(!is.null(m)) {
message("getting cached data")
return(m) # returnes inv if inverse was already cached
}
data <- x$get() # gets the matrix from the makeCacheMatrix function
m <- solve(data)
x$set.inv(m) # setting the inverted matrix into makeCacheMatrix
m
}
cacheSolve(a2)
a2$get.inv() # should show the inverse
cacheSolve(a2)
a2$set(matrix(c(1,-5,0,0,1,0,0,0,1),3,3))
a2$get.inv()
cacheSolve(a2)
cacheSolve(a2)
a2$get()
a2$set.inv(matrix(c(1,-5,0,0,1,-5,-3,0,1),3,3))
a2$get.inv()
a2$get()
rm(list = ls())
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(inverse) m <<- inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The second function "cacheSolve" returns the inverse of "x".
## If the inverse has already been calculated (and the matrix has not changed), then "cacheSolve" retrieves
## the inverse from the cache.
cacheSolve <- function(x) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve (data)
x$setinverse(m)
m
}
a<-matrix(1:4,2,2)
a
a2<-makeCacheMatrix(a)
a2$get()
a2$get.inv()
rm(list = ls())
makeCacheMatrix <- function(x = matrix()) {
m <- NULL # creates a varialbe called inv
set <- function(y) { # creates a set variable, copies the matrix (uses x from the upper environment)
x <<-  y
m <<- NULL # setting inv to null
}
get <- function() x # getting the x matrix
set.inv <- function(inverse)m <<- inverse # setting the inv matrix
get.inv <- function() m # getting the inverted matrix -  after applying cacheSolve
list(set = set, get = get,
set.inv = set.inv,
get.inv = get.inv) #  creating public variables
}
a<-matrix(1:4,2,2)
a
a2<-makeCacheMatrix(a)
a2$get()
a2$get.inv()
rm(list = ls())
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(inverse) m <<- inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
a<-matrix(1:4,2,2)
a
a2<-makeCacheMatrix(a)
a2$get()
a2$get.inv()
makeCacheMatrix <- function(x = matrix()) {
m <- NULL # creates a varialbe called inv
set <- function(y) { # creates a set variable, copies the matrix (uses x from the upper environment)
x <<-  y
m <<- NULL # setting inv to null
}
get <- function() x # getting the x matrix
set.inv <- function(inverse)m <<- inverse # setting the inv matrix
get.inv <- function() m # getting the inverted matrix -  after applying cacheSolve
list(set = set, get = get,
set.inv = set.inv,
get.inv = get.inv) #  creating public variables
}
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(inverse) m <<- inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
a<-matrix(1:4,2,2)
a
a2<-makeCacheMatrix(a)
a2$get()
a2$get.inv()
rm(list = ls())
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(inverse) m <<- inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The second function "cacheSolve" returns the inverse of "x".
## If the inverse has already been calculated (and the matrix has not changed), then "cacheSolve" retrieves
## the inverse from the cache.
cacheSolve <- function(x) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve (data)
x$setinverse(m)
m
}
a<-matrix(1:4,2,2)
a
a2<-makeCacheMatrix(a)
a2$get()
a2$getinverse()
cacheSolve(a2)
a2$getinverse() # should show the inverse
cacheSolve(a2)
a2$set(matrix(c(1,-5,0,0,1,0,0,0,1),3,3))
a2$getinverse()
cacheSolve(a2)
cacheSolve(a2)
a2$get()
a2$set.inv(matrix(c(1,-5,0,0,1,-5,-3,0,1),3,3))
a2$setinverse(matrix(c(1,-5,0,0,1,-5,-3,0,1),3,3))
a2$getinverse()
a2$get()
b <- matrix(1:16,4,4)
b2 <- makeCacheMatrix(b)
cacheSolve(b2)
b <- matrix(1:9,3,3)
b
b2 <- makeCacheMatrix(b)
cacheSolve(b2)
install.packages("tikzDevice")
sessionInfo()
install.packages("pandoc")
?compare.timing
??compare.timing
install.packages("stringi")
? bidi
# Getting and Cleaning Data - Course Project
# You should create one R script called run_analysis.R that does the following.
# 1. Merges the training and the test sets to create one data set.
# 2. Extracts only the measurements on the mean and standard deviation for each measurement.
# 3. Uses descriptive activity names to name the activities in the data set
# 4. Appropriately labels the data set with descriptive variable names.
# 5. From the data set in step 4, creates a second, independent tidy data set with the
# average of each variable for each activity and each subject.
# loading packages
library(reshape2)
setwd("/media/hadas/OS/Documents and Settings/user/Google Drive/OnlineCourses/R_Data_Science_Specialization/03_Getting_and_cleaning_data/Programming_Assignments/CourseProject")
#-----
# downloading and unzipping the file
if(!file.exists("./data")) {
#creating a temp directory for the zip file
temp <- tempfile()
# downloading the zip file
file_url <- "https://d396qusza40orc.cloudfront.net/getdata%2Fprojectfiles%2FUCI%20HAR%20Dataset.zip"
download.file(file_url, destfile = temp , method = "wget")
# unziping the file
unzip(temp)
unlink(temp)
# checking the folder name
zip_filename <- dir()[file.info(dir())$isdir]
#renaming the new folder to data
file.rename(zip_filename, "data")
}
# lists the files in the zip folder
list.dirs(path = "./data")
#--------
# 1. Merges the training and the test sets to create one data set.
#-----
## reading and recoding the feature lables
# reading the txt files
feature_labels <- read.table("./data/features.txt", sep = "", header = FALSE)
dim(feature_labels)
## transforming names to names human readable
# transforming to lower case
feature_labels$V2 <- tolower(feature_labels$V2)
#replacing all pnctuations with a dot
feature_labels$V2 <- gsub("[[:punct:]+]", ".", feature_labels$V2)
#deleting all spaces
feature_labels$V2 <- gsub("\\s+", "", feature_labels$V2, perl=TRUE)
# deleting 2 dots
feature_labels$V2 <- gsub("[â€¢.,]{2}", "", feature_labels$V2, perl = TRUE)
#deleting dots at the end
feature_labels$V2 <- gsub("\\.$", "", feature_labels$V2, perl = TRUE)
#----
## reading train files
# reading train data
train_df <- read.table("./data/train/X_train.txt", sep = "", header = FALSE, col.names = feature_labels$V2)
# reading train subjects
train_subjects <- read.table("./data/train/subject_train.txt", sep = "",
header = FALSE, col.names = "subject")
# reading train labels
train_labels <- read.table("./data/train/y_train.txt", sep = "",
header = FALSE, col.names = "activity_label")
# merging the train data with the subjects
train_data <- cbind(train_subjects, train_labels, train_df)
# adding a new variable - group
train_data$group <- "train"
#----
## reading test data
test_df <- read.table("./data/test/X_test.txt", sep = "", header = FALSE,
col.names = feature_labels$V2)
# reading test subjsts
test_subjects <- read.table("./data/test/subject_test.txt", sep = "", header = FALSE,
col.names = "subject")
# reading test labels
test_labels <- read.table("./data/test/y_test.txt", sep = "", header = FALSE,
col.names = "activity_label")
# mearging the test files
test_data <- cbind(test_subjects, test_labels, test_df)
# adding a new variable - group
test_data$group <- "test"
#-----
## combining the train and test datasets
data_temp <- rbind(train_data,test_data)
#-----
## reading the activity label
activity_labels <- read.table("./data/activity_labels.txt", sep = "", header = FALSE,
col.names = c("activity_label", "activity"))
#---
## adding activity label to the dataset
data <- merge(activity_labels, data_temp, by = "activity_label")
#----
#  Extracts only the measurements on the mean and standard deviation for each measurement.
data_clean <- data[,c(2, 3, grep("mean", colnames(data)), grep("std", colnames(data)))]
# changing subjects to factor
data_clean$subject <- as.factor(data_clean$subject)
#-----
# 5. From the data set in step 4, creates a second, independent tidy data set with the
# average of each variable for each activity and each subject.
#reshaping the dataset using melt (reshape2 package)
melt_data <- melt(data_clean, id = c("subject", "activity"))
#  caculating the mean function using dcast
data_tidy <- dcast(melt_data, subject + activity ~ variable, mean)
# ---
# saving the data_tidy df as a txt file
write.table(data_tidy, file = "./data_tidy.txt", row.name = FALSE )
View(head(train_df))
unique(train_subjects)
unique(test_subjects)
unique(train_label)
unique(train_labels)
